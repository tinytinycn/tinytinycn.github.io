<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> python-07-面向对象高级编程 · hang 's blogs</title><meta name="description" content="python-07-面向对象高级编程 - hang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/tinytinycn.github.io/favicon.png"><link rel="stylesheet" href="/tinytinycn.github.io/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://github.com/atom.xml" title="hang 's blogs"></head><body><div class="wrap"><header><a href="/tinytinycn.github.io/" class="logo-link"><img src="/tinytinycn.github.io/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/tinytinycn.github.io/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/tinytinycn.github.io/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/tinytinycn.github.io/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">python-07-面向对象高级编程</h1><div class="post-info">Sep 13, 2018</div><div class="post-content"><h3 id="solts"><a href="#solts" class="headerlink" title="__solts"></a>__solts</h3><ul>
<li><p>先定义class, 后绑定属性和方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">from types import MethodType</span><br><span class="line">def set_age(self, age): # 定义一个函数作为实例方法</span><br><span class="line">    self.age=age</span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.name = &apos;tiny&apos;</span><br><span class="line">s.age = 25 //25</span><br><span class="line">s.set_age = MethodType(set_age, s) //绑定方法到实例s, 该方法只作用该实例</span><br><span class="line">s.set_age(26)</span><br><span class="line">s.age //26</span><br><span class="line"></span><br><span class="line">def set_score(self, score):</span><br><span class="line">    self.score=score</span><br><span class="line"></span><br><span class="line">Student.set_score=set_score //一般类方法直接定义在class中, 动态绑定允许在运行过程中动态给class加上方法, 使得该方法作用所有实例</span><br><span class="line">s1.set_score(100)</span><br><span class="line">s1.score //100</span><br><span class="line">s2.set_score(99)</span><br><span class="line">s2.score //99</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义class时使用<code>__slots__</code>变量, 限制class实例属性的添加. 但不限制该class的子类实例属性的添加!!!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    __slots__ =(&apos;name&apos;, &apos;age&apos;)</span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.name = &apos;tiny&apos;</span><br><span class="line">s.age = 25</span><br><span class="line">s.score = 100 //AttributeError 报错</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h3><p>@property装饰器负责把一个方法变成属性调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    @property</span><br><span class="line">    def score(self):</span><br><span class="line">        return self.score</span><br><span class="line">    @score.setter</span><br><span class="line">    def score(self, val):</span><br><span class="line">        if not isinstance(val, int):</span><br><span class="line">            raise ValueError(&apos;score must be an integer!!&apos;)</span><br><span class="line">        if value&lt;0 or value&gt;100:</span><br><span class="line">            raise ValueError(&apos;score must between 0-100&apos;)</span><br><span class="line">        self.score=val</span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.score = 99 //实际转化为 s.set_score(99)</span><br><span class="line">s.score 　　　　　//实际转化为 s.get_score()</span><br></pre></td></tr></table></figure>

<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><ul>
<li>MixIn的目的是给一个类增加多个功能, 通过多重继承组合多个MixIn功能, 而不是设计多层次复杂的继承关系.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Mammal, RunnableMixIn, CarnivaorousMixIn):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h3><ul>
<li><p><code>__str__()</code>定制print(Student())的信息</p>
</li>
<li><p><code>__repr__()</code>定制s的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name=name</span><br><span class="line">    def __str__(self):</span><br><span class="line">        print(&apos;student object (name:&#123;1&#125;))&apos;.format(self.name))</span><br><span class="line">    __repr__=__str__</span><br><span class="line"></span><br><span class="line">s = Student(&apos;tiny&apos;) //实际调用__str__()</span><br><span class="line">s //实际调用__repr__()</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个类实现<code>__iter__()</code>方法返回一个迭代对象, 调用迭代对象<code>__next__()</code>方法拿到循环的下一个值, 知道StopIteration错误推出循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class　Fib(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.a,self.b=0,1</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.a,self.b=self.b,self.a+self.b</span><br><span class="line">        if self.a&gt;1000:</span><br><span class="line">            raise StopIteration()</span><br><span class="line">        return self.a</span><br><span class="line"></span><br><span class="line">for n in Fib():</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__getitem__()</code>方法使得对象可以像list一样按下标或切片slice去元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">    def __getitem__(self, n):</span><br><span class="line">      if isinstance(n, int):</span><br><span class="line">        a,b=1,1</span><br><span class="line">        for x in range(n):</span><br><span class="line">            a,b=b,a+b</span><br><span class="line">        return a</span><br><span class="line">      if isinstance(n, slice):</span><br><span class="line">        start = n.start</span><br><span class="line">        stop = n.stop</span><br><span class="line">        if start is None:</span><br><span class="line">           start=0</span><br><span class="line">        a,b=1,1</span><br><span class="line">        L=[]</span><br><span class="line">        for x in range(stop):</span><br><span class="line">            if x&gt;=start:</span><br><span class="line">                L.append(a)</span><br><span class="line">            a,b=b,a+b</span><br><span class="line">        return L</span><br><span class="line"></span><br><span class="line">f=Fib()</span><br><span class="line">f[0:5] //[1,1,2,3,5], 注意程序没有对f[2:5]做处理!!!</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__getitem__()</code> <code>__setitem__()</code> <code>__delitem__()</code>方法使得自定义类表现得和list,tuple,dict很像, 归功于动态语言的’鸭子类型’, 不需要强制继承某个接口</p>
</li>
<li><p><code>__getattr__()</code>动态返回一个属性, 当调用一个实例的属性时, 在没有该属性时, 才调用<code>__getattr__()</code>方法, 默认返回None</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __getattr__(self, attr):</span><br><span class="line">        if attr==&apos;age&apos;:</span><br><span class="line">           return lambda:25</span><br><span class="line">        raise AttributeError(&apos;student object has no attribute &#123;1&#125;&apos;.format(attr))</span><br><span class="line"></span><br><span class="line">s.age //25</span><br><span class="line">s.score //AttributeError错误</span><br><span class="line"></span><br><span class="line">class Chain(object):</span><br><span class="line">    def __init__(self, path=&apos;&apos;):</span><br><span class="line">        self._path=path</span><br><span class="line">    def __getattr__(self, path):</span><br><span class="line">        return Chain(&apos;&#123;1&#125;/&#123;2&#125;&apos;.format(self._path, path))</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self._path</span><br><span class="line">    __repr__=__str__</span><br><span class="line"></span><br><span class="line">Chain().status.user.timeline.list //链式调用:&apos;/status/user/timeline/list&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__call__()</code>方法使得对象可以看成函数, 接调用实例本身的方法. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name=name</span><br><span class="line">    def __call__(self):</span><br><span class="line">        pritn(&apos;hello, &#123;1&#125;&apos;.format(self.name))</span><br><span class="line"></span><br><span class="line">s = Student(&apos;tiny&apos;)</span><br><span class="line">s() //&apos;hello, tiny&apos; 对实例直接进行调用就像一个函数的调用一样, 判断一个变量是对象还是函数, 看能被调用对象是否为Callable对象, 比如自定义类带有__call__()方法</span><br><span class="line">callable(Student()) //True</span><br><span class="line">callable(max)       //True</span><br><span class="line">callable([1,2,3])   //False</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><ul>
<li><p>value属性自动赋值int常量, 默认从1开始计数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line">Month=Enum(&apos;Month&apos;,(&apos;Jan&apos;,&apos;Feb&apos;,&apos;Mar&apos;))</span><br><span class="line"></span><br><span class="line">for name,member in Month.__members__.items():</span><br><span class="line">    print(&apos;&#123;0&#125;=&gt;&#123;1&#125;,&#123;2&#125;&apos;.format(name, member, member.value))</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@unique</code>装饰器保证没有重复值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum,unique</span><br><span class="line"></span><br><span class="line">@unique</span><br><span class="line">class Weekday(Enum):</span><br><span class="line">    Sun=0</span><br><span class="line">    Mon=1</span><br><span class="line">    Tue=2</span><br><span class="line">    Wed=3</span><br><span class="line">    Thu=4</span><br><span class="line">    Fri=5</span><br><span class="line">    Sat=6</span><br><span class="line"></span><br><span class="line">d = Weekday.Mon    //Weekday.Mon</span><br><span class="line">d2= Weekday[&apos;Tue&apos;] //Weekday.Tue</span><br><span class="line">d3= Weekday.Tue.value //2</span><br><span class="line">d4= Weekday(3)     //Weekday.Wed</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h3><ul>
<li>type()函数可以查看类型或变量的类型</li>
<li>type()函数可以运行期动态创建class<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def fn(self, name=&apos;tiny&apos;):</span><br><span class="line">    print(&apos;i am &#123;0&#125;&apos;.format(name))</span><br><span class="line"></span><br><span class="line">Hello = type(&apos;Hello&apos;, (object,), dict(say=fn)) //创建Hello类, 绑定say方法(fn)</span><br><span class="line">h=Hello()</span><br><span class="line">h.say() //hello, tiny</span><br><span class="line">print(type(Hello)) //&lt;class &apos;type&apos;&gt;</span><br><span class="line">print(type(h))     //&lt;class &apos;__main__.Hello&apos;&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="metaclass"><a href="#metaclass" class="headerlink" title="metaclass"></a>metaclass</h3><ul>
<li><p>元类, 动态创建类, 控制类的创建行为</p>
</li>
<li><p>先定义metaclass, 接下来创建类, 最后创建实例</p>
</li>
<li><p><code>__new__()</code>方法依次接收参数: 当前准备创建类的对象/类名/父类集合/类方法集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">`#` metaclass是类的模板, 必须从`type`类型派生</span><br><span class="line">class ListMetaclass(type):</span><br><span class="line">    def __new__(cls, name, bases, attrs):</span><br><span class="line">        attrs[&apos;add&apos;]=lambda self,value: self.append(value) //添加新方法</span><br><span class="line">        return type.__new__(cls, name, bases, attrs)</span><br><span class="line">`#` 指定定制类</span><br><span class="line">class MyList(list, metaclass=ListMetaclass):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">`#` 创建MyList时, 要通过ListMetaclass.__new__()创建, 因此可以修改类的定义, 添加新方法</span><br><span class="line">L = MyList()</span><br><span class="line">L.add(1) //普通List没有add方法</span><br><span class="line">L //[1]</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个简单的ORM框架实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/local/bin/python3</span><br><span class="line">class Field(object):</span><br><span class="line">    def __init__(self,name,col_type):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.col_type=col_type</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &apos;&#123;0&#125;:&#123;1&#125;&apos;.format(self.__class__.__name__,self.name)</span><br><span class="line"></span><br><span class="line">class StringField(Field):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        super(StringField, self).__init__(name,&apos;varchar(100)&apos;)</span><br><span class="line"></span><br><span class="line">class IntegerField(Field):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        super(IntegerField, self).__init__(name, &apos;bigint&apos;)</span><br><span class="line"></span><br><span class="line">class ModelMetaclass(type):</span><br><span class="line">    def __new__(cls, name, bases, attrs):</span><br><span class="line">        if name==&apos;Model&apos;:</span><br><span class="line">            return type.__new__(cls, name, bases, attrs)</span><br><span class="line">        print(&apos;found model: &#123;0&#125;&apos;.format(name))</span><br><span class="line">        mappings=dict()</span><br><span class="line">        for k,v in attrs.items():</span><br><span class="line">            if isinstance(v, Field):</span><br><span class="line">                print(&apos;found mapping: &#123;0&#125;:&#123;1&#125;&apos;.format(k,v))</span><br><span class="line">                mappings[k]=v</span><br><span class="line">        for k in mappings.keys():</span><br><span class="line">            attrs.pop(k)</span><br><span class="line">        attrs[&apos;__mappings__&apos;]=mappings</span><br><span class="line">        attrs[&apos;__table__&apos;]=name</span><br><span class="line">        return type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line">class Model(dict, metaclass=ModelMetaclass):</span><br><span class="line">    def __init__(self, **kw):</span><br><span class="line">        super(Model, self).__init__(**kw)</span><br><span class="line">    def __getattr__(self, key):</span><br><span class="line">        try:</span><br><span class="line">            return self[key]</span><br><span class="line">        except KeyError:</span><br><span class="line">            raise AttributeError(&apos;model object has no attribute &#123;0&#125;&apos;.format(key))</span><br><span class="line">    def __setattr__(self, key, value):</span><br><span class="line">        self[key]=value</span><br><span class="line">    def save(self):</span><br><span class="line">        fields=[]</span><br><span class="line">        params=[]</span><br><span class="line">        args=[]</span><br><span class="line">        for k,v in self.__mappings__.items():</span><br><span class="line">            fields.append(v.name)</span><br><span class="line">            params.append(&apos;?&apos;)</span><br><span class="line">            args.append(getattr(self, k, None))</span><br><span class="line">        sql=&apos;insert into %s (%s) values (%s)&apos; % (self.__table__,&apos;,&apos;.join(fields), &apos;,&apos;.join(params))</span><br><span class="line">        print(&apos;SQL: &#123;0&#125;&apos;.format(sql))</span><br><span class="line">        print(&apos;ARGS: &#123;0&#125;&apos;.format(str(args)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class User(Model):</span><br><span class="line">    id=IntegerField(&apos;id&apos;)</span><br><span class="line">    name=StringField(&apos;username&apos;)</span><br><span class="line">    email=StringField(&apos;email&apos;)</span><br><span class="line">    password=StringField(&apos;password&apos;)</span><br><span class="line"></span><br><span class="line">u = User(id=123, name=&apos;tiny&apos;, email=&apos;t.tt@t.tt&apos;, password=&apos;pass&apos;)</span><br><span class="line">u.save()</span><br></pre></td></tr></table></figure>

</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/tinytinycn.github.io/2018/09/13/python-08-错误调试测试/" class="prev">上一篇</a><a href="/tinytinycn.github.io/2018/09/12/python-06-面向对象编程/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://github.com">hang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>