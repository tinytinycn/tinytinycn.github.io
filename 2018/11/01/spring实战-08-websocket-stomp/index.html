<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> spring实战-08-websocket-stomp · hang 's blogs</title><meta name="description" content="spring实战-08-websocket-stomp - hang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/tinytinycn.github.io/favicon.png"><link rel="stylesheet" href="/tinytinycn.github.io/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://github.com/atom.xml" title="hang 's blogs"></head><body><div class="wrap"><header><a href="/tinytinycn.github.io/" class="logo-link"><img src="/tinytinycn.github.io/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/tinytinycn.github.io/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/tinytinycn.github.io/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/tinytinycn.github.io/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">spring实战-08-websocket-stomp</h1><div class="post-info">Nov 1, 2018</div><div class="post-content"><h3 id="spring实战-第十八章-websocket-amp-stomp-实现消息功能"><a href="#spring实战-第十八章-websocket-amp-stomp-实现消息功能" class="headerlink" title="spring实战 第十八章 websocket &amp; stomp 实现消息功能"></a>spring实战 第十八章 websocket &amp; stomp 实现消息功能</h3><p>websocket协议提供了通过一个套接字实现全双工通信的功能. 能够实现web浏览器和服务器的”异步”通信. spring4.0支持websocket通讯.</p>
<ol>
<li>底层WebSocket api使用/SockJS api使用</li>
</ol>
<ul>
<li><p>实现一个消息处理类(可以实现WebSocketHandler接口/可以继承AbstactWebSocketHandler抽象类/可以继承TextWebSocketHandler实现类), 实现各种处理方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TinyHandler extends TextWebSocketHandler&#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现一个websocket配置类(可以实现WebSocketConfigurer接口)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocket</span><br><span class="line">public class WebSocketConfig implements WebSocketConfigurer&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void registerWebSocketHanders(WebSocketHandlerRegistry registry)&#123;</span><br><span class="line">        registry.addHandler(tinyHandler(), &quot;/tiny&quot;).setAllowedOrigins(&quot;*&quot;);</span><br><span class="line">        //registry.addHandler(tinyHandler(), &quot;/tiny&quot;).setAllowedOrigins(&quot;*&quot;).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public TinyHandler tinyHandler() &#123;</span><br><span class="line">        return new TinyHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>javascript客户端实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--使用SockJS时引入--&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    //使用原生WebSock时,采用此方式</span><br><span class="line">    var url = &apos;ws://localhost:8080/tiny&apos;;</span><br><span class="line">    var sock = new WebSock(url);</span><br><span class="line">    //使用SockJS时,采用以下方式(注意: 协议ws/http区别, 这里必须是http或https)</span><br><span class="line">    //var url = &apos;http://localhost:8080/tiny&apos;;</span><br><span class="line">    //var sock = new SockJS(url);</span><br><span class="line">    sock.onopen = function () &#123;</span><br><span class="line">        console.log(&apos;opening&apos;);</span><br><span class="line">        sendHi();</span><br><span class="line">    &#125;</span><br><span class="line">    sock.onmessage = function (ev) &#123;</span><br><span class="line">        console.log(&apos;received message: &apos; + ev.data);</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            sendHi()</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;</span><br><span class="line">    sock.onclose = function () &#123;</span><br><span class="line">        console.log(&apos;closing&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sendHi() &#123;</span><br><span class="line">        console.log(&apos;sending hi to server&apos;);</span><br><span class="line">        sock.send(&apos;hi from browser&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>stomp 的使用<br>stomp是一个消息协议, 类似jms/amqp. 消息会发布到某个destination目的地, 这个目的地可能有message broker消息代理作为支撑. 同时又有message handler消息处理器监听这个目的地, 接受发送过来的消息. 客户端和服务端的组件通过目的地收发消息. </li>
<li>1 启动stomp功能</li>
</ol>
<ul>
<li>实现一个配置类, 添加@EnableWebSocketMessageBroker注解, 实现WebSocketMessageBrokerConfigurer接口, 还必须配置一个消息代理和一个消息目的地<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocketMessageBroker</span><br><span class="line">public class WebSocketStompConfig implements WebSocketMessageBrokerConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void registerStompEndpoints(StompEndpointRegistry registry) &#123;</span><br><span class="line">        registry.addEndpoint(&quot;/tinyendpoint&quot;).setAllowedOrigins(&quot;*&quot;).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureMessageBroker(MessageBrokerRegistry registry) &#123;</span><br><span class="line">        registry.enableSimpleBroker(&quot;/topic&quot;);</span><br><span class="line">        registry.setApplicationDestinationPrefixes(&quot;/app&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>2.2 处理客户端发来的stomp消息</p>
<ul>
<li><p>实现一个controller类, 添加@MessageMapping/@SubscribeMapping注解到处理方法上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TinyStompController &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(TinyStompController.class);</span><br><span class="line"></span><br><span class="line">    @MessageMapping(&quot;/sendAAA&quot;)</span><br><span class="line">    public void handleShout(Shout incoming) &#123;</span><br><span class="line">        logger.info(&quot;received message: &quot; + incoming.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SubscribeMapping(&#123;&quot;/subscribeBBB&quot;&#125;)</span><br><span class="line">    public Shout handleSubscription() &#123;</span><br><span class="line">        logger.info(&quot;subscription ...&quot;);</span><br><span class="line">        Shout shout = new Shout();</span><br><span class="line">        shout.setMessage(&quot;tiny!&quot;);</span><br><span class="line">        return shout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现一个消息实体POJO类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Shout &#123;</span><br><span class="line">    private String message;</span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现javascript客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--使用SockJS时引入--&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!--使用Stomp时引入--&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/stomp.js/2.3.3/stomp.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var url = &apos;http://localhost:8080/tinyendpoint&apos;;</span><br><span class="line">    var sock = new SockJS(url);</span><br><span class="line">    var stomp = Stomp.over(sock);</span><br><span class="line">    var payload = JSON.stringify(&#123;&apos;message&apos;: &apos;hello!&apos;&#125;);</span><br><span class="line">    stomp.connect(&#123;&#125;, function (frame) &#123;</span><br><span class="line">        //发送消息到服务端</span><br><span class="line">        // stomp.send(&quot;/app/sendAAA&quot;, &#123;&#125;, payload);</span><br><span class="line">        //发送订阅消息到服务端</span><br><span class="line">        stomp.subscribe(&quot;/app/subscribeBBB&quot;, handleMessage);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    function handleMessage(incoming) &#123;</span><br><span class="line">        var result = JSON.parse(incoming.body);</span><br><span class="line">        console.log(&apos;subscribe: &apos; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>2.3 发送消息到客户端</p>
<ul>
<li>处理消息后, 发送附带消息<br>值得注意的是, @MessageMapping注释的方法, 处理完消息后, 返回的消息通过broker channel代理通道发送到消息代理, 此时, 如上述例子中, 由原来的消息目的地/app/sendAAA, 变成新的目的地/topic/sendAAA(自动剥离掉前缀/app, 添加新的前缀/topic), 再发送给消息代理. 我们也可以添加@SendTo注释到方法, 指定处理完后发往的目的地/topic/sendCCC.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@MessageMapping(&quot;/sendAAA&quot;)</span><br><span class="line">@SendTo(&quot;/topic/sendCCC&quot;)</span><br><span class="line">public Shout handleShout(Shout incoming) &#123;</span><br><span class="line">    logger.info(&quot;received message: &quot; + incoming.getMessage());</span><br><span class="line">    Shout shout = new Shout();</span><br><span class="line">    shout.setMessage(&quot;tiny!&quot;);</span><br><span class="line">    return shout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>另外, @SubscribeMapping注释的方法, 处理完订阅消息后, 直接返回消息到客户端. 如果添加@SendTo注解, 也可以指定发往的目的地, 同样也会经过消息代理.</p>
<ul>
<li>使用消息模版<br>通过消息模版的方法, 主动发送消息到目的地, 使得客户端收到消息.</li>
</ul>
<ol start="3">
<li>发送消息到指定用户</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/tinytinycn.github.io/2018/11/13/fix-wps-fonts/" class="prev">PREV</a><a href="/tinytinycn.github.io/2018/10/29/springboot-03-https服务/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://github.com">hang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>